<!-- Fondo principal -->
<div id="main-background"></div>

<!-- Animación de frames -->
<div id="frames-animation"></div>

<!-- Capa de gradiente (mantenida para compatibilidad) -->
<div id="gradient-layer"></div>

<!-- Contenido principal que usa ScrollTrigger como trigger -->
<div id="main-content" class="relative">
  <section class="hero-section">
    <div id="hero-key" class="hero-content"></div>
  </section>
</div>

<!-- Nueva etiqueta main separada para la segunda timeline (evita conflictos) -->
<main>
  <!-- Aquí va el contenido que antes estaba dentro de #main-content para la segunda timeline -->
  <header class="header"></header>
  <div class="logo-text"></div>
  <div class="main-content">
    <h1>Title</h1>
    <p>Paragraph</p>
  </div>
</main>

<!-- Capa de máscara -->
<div id="logo-mask"></div>

<!-- Ícono de scroll -->
<div class="keep-scrolling">
  <svg
    width="34"
    height="14"
    viewBox="0 0 34 14"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M33.5609 1.54346C34.0381 2.5875 33.6881 3.87821 32.7791 4.42633L17.0387 13.9181L1.48663 4.42115C0.580153 3.86761 0.235986 2.57483 0.717909 1.53365C1.19983 0.492464 2.32535 0.097152 3.23182 0.650692L17.0497 9.08858L31.051 0.64551C31.96 0.0973872 33.0837 0.499411 33.5609 1.54346Z"
      fill="currentColor"></path>
  </svg>
</div>

<!-- Cargar GSAP y ScrollTrigger antes del script principal -->
<script
  is:inline
  src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script
  is:inline
  src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"
></script>
<script is:inline>
  // GSAP y ScrollTrigger ya están disponibles globalmente desde los CDN
  gsap.registerPlugin(ScrollTrigger);

  // Cargar y configurar la animación de frames
  const framesContainer = document.getElementById("frames-animation");
  const totalFrames = 89;
  let currentFrame = 0;
  const frames = [];
  let framesLoaded = 0;

  // Variables para controlar el estado de las timelines
  let firstTimelineComplete = false;
  let isHiding = false;
  let lastScrollProgress = 0;

  // Precargar y crear elementos de imagen para cada frame
  function preloadFrames() {
    return new Promise((resolve) => {
      for (let i = 1; i <= totalFrames; i++) {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = `/assets/frames/1 (${i}).webp`;
        img.alt = `Frame ${i}`;
        img.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        opacity: 0;
        pointer-events: none;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
      `;

        img.onload = () => {
          framesLoaded++;
          if (framesLoaded === totalFrames) {
            resolve();
          }
        };

        img.onerror = () => {
          console.warn(`Failed to load frame ${i}`);
          framesLoaded++;
          if (framesLoaded === totalFrames) {
            resolve();
          }
        };

        framesContainer.appendChild(img);
        frames.push(img);
      }
    });
  }

  let isAnimating = false;
  let lastRenderedFrame = -1;

  function showFrame(frameIndex) {
    // Evitar actualizaciones innecesarias
    if (frameIndex === lastRenderedFrame || !frames[frameIndex]) return;

    // Evitar solapamiento de animaciones
    if (isAnimating) return;
    isAnimating = true;

    // Usar requestAnimationFrame para sincronizar con el renderizado del navegador
    requestAnimationFrame(() => {
      try {
        // Ocultar el frame actual si existe
        if (frames[currentFrame] && currentFrame !== frameIndex) {
          frames[currentFrame].style.display = "none";
        }

        // Mostrar el nuevo frame
        const targetFrame = frames[frameIndex];
        targetFrame.style.display = "block";
        targetFrame.style.opacity = "1";

        // Actualizar el frame actual
        currentFrame = frameIndex;
        lastRenderedFrame = frameIndex;
      } catch (error) {
        console.error("Error in showFrame:", error);
      } finally {
        isAnimating = false;
      }
    });
  }

  // Función para inicializar el contenido de la segunda timeline
  function initializeSecondTimeline() {
    const secondTimelineContent = document.querySelector("main");
    if (secondTimelineContent) {
      gsap.set(secondTimelineContent, {
        opacity: 0,
        x: "100%",
        scale: 0.7,
        rotationY: 45,
        visibility: "visible",
        pointerEvents: "none",
      });
      console.log("Segunda timeline inicializada y ocultada");
    }
  }

  // Función para ocultar la segunda timeline
  function hideSecondTimeline() {
    const secondTimelineContent = document.querySelector("main");
    const logoMask = document.querySelector("#logo-mask");

    // Ocultar instantáneamente el contenido de la segunda timeline
    if (secondTimelineContent) {
      gsap.set(secondTimelineContent, {
        opacity: 0,
        pointerEvents: "none",
      });
    }
    if (logoMask) {
      gsap.set(logoMask, { opacity: 1 });
    }

    // IMPORTANTE: No reiniciamos firstTimelineComplete a false
    // para que la animación de entrada no se repita.
  }

  // Función para activar la segunda timeline con animaciones rápidas
  window.activateSecondTimeline = () => {
    if (firstTimelineComplete) {
      console.log("Segunda timeline ya está activa, saltando...");
      return;
    }

    firstTimelineComplete = true;
    isHiding = false;
    console.log("Activando segunda timeline...");

    const secondTimelineContent = document.querySelector("main");
    const logoMask = document.querySelector("#logo-mask");
    const header = document.querySelector("main .header");
    const logoText = document.querySelector("main .logo-text");
    const mainContent = document.querySelector("main .main-content");
    const title = document.querySelector("main .main-content h1");
    const paragraph = document.querySelector("main .main-content p");

    if (!secondTimelineContent) {
      console.error("No se encontró el contenido de la segunda timeline");
      return;
    }

    // Timeline de entrada rápida y dinámica
    const entryTimeline = gsap.timeline({
      ease: "power3.out",
    });

    // 1. Ocultar logo-mask rápidamente
    entryTimeline.to(logoMask, {
      opacity: 0,
      duration: 1.5,
      ease: "power3.inOut",
    });

    // 2. Preparar el contenedor
    entryTimeline.set(secondTimelineContent, {
      pointerEvents: "auto",
      zIndex: 100,
    });

    // 3. Animación principal de entrada - slide desde la derecha con rotación
    entryTimeline.to(
      secondTimelineContent,
      {
        x: "0%",
        scale: 1,
        rotationY: 0,
        opacity: 1,
        duration: 0.6,
        ease: "power3.out",
      },
      "<0.1",
    );

    // 4. Header entra desde arriba rápidamente
    if (header && logoText) {
      entryTimeline.fromTo(
        header,
        {
          y: -60,
          opacity: 0,
          scale: 0.8,
        },
        {
          y: 0,
          opacity: 1,
          scale: 1,
          duration: 0.5,
          ease: "back.out(2)",
        },
        "<0.2",
      );
    }

    // 5. Título entra desde la derecha
    if (title) {
      entryTimeline.fromTo(
        title,
        {
          x: 80,
          y: 30,
          opacity: 0,
          scale: 0.7,
          rotation: 5,
        },
        {
          x: 0,
          y: 0,
          opacity: 1,
          scale: 1,
          rotation: 0,
          duration: 0.6,
          ease: "back.out(1.8)",
        },
        "<0.1",
      );
    }

    // 6. Párrafo entra desde abajo con slide
    if (paragraph) {
      entryTimeline.fromTo(
        paragraph,
        {
          y: 50,
          x: -30,
          opacity: 0,
          scale: 0.9,
        },
        {
          y: 0,
          x: 0,
          opacity: 1,
          scale: 1,
          duration: 0.5,
          ease: "power3.out",
        },
        "<0.15",
      );
    }

    // 7. Efecto final sutil en el título
    entryTimeline.to(
      title,
      {
        scale: 1.03,
        duration: 0.2,
        ease: "power2.inOut",
        yoyo: true,
        repeat: 1,
      },
      "<0.3",
    );

    console.log("Segunda timeline activada completamente");
  };

  // Mostrar el gradiente al cargar la página
  document.addEventListener("DOMContentLoaded", async () => {
    initializeSecondTimeline();

    await preloadFrames();

    // Mostrar el primer frame instantáneamente
    if (frames[0]) {
      frames[0].style.display = "block";
      frames[0].style.opacity = "1";
    }

    // Forzar que ScrollTrigger se calcule y active
    ScrollTrigger.refresh();

    // Forzar render inmediato del primer frame
    gsap.set("#frames-animation", { opacity: 1, immediateRender: true });
    showFrame(0);

    // Configurar la animación principal después de cargar los frames
    setupMainAnimation();
  });

  function setupMainAnimation() {
    // Timeline principal con ScrollTrigger
    const mainTimeline = gsap.timeline({
      ease: "power2.inOut",
      scrollTrigger: {
        trigger: "#main-content",
        start: "top top",
        end: "bottom bottom",
        scrub: 0.5,
        onUpdate: (self) => {
          const progress = self.progress;
          const frameSectionProgress = Math.min(progress / 0.7, 1);

          if (progress <= 0.7) {
            gsap.set("#frames-animation", {
              opacity: 1,
              immediateRender: false,
            });

            // Calcular el frame actual basado en el progreso
            const targetFrame = Math.min(
              Math.floor(frameSectionProgress * (totalFrames - 1)),
              totalFrames - 1,
            );
            if (targetFrame !== lastRenderedFrame) {
              showFrame(targetFrame);
            }
          } else if (progress > 0.68 && self.direction === 1 && !isHiding) {
            isHiding = true; // evitar que se repita
            gsap.to("#frames-animation", {
              opacity: 0,
              duration: 0.8,
              ease: "power2.inOut",
              onComplete: () => {
                frames.forEach((frame) => {
                  if (frame) frame.style.display = "none";
                });
                // Reinicia el estado para futuras entradas
                setTimeout(() => (isHiding = false), 1000);
              },
            });
          }
        },
        onLeave: () => {
          // Ocultar #frames-animation gradualmente
          gsap.to("#frames-animation", {
            opacity: 0,
            duration: 0.5,
            ease: "power2.in",
            onComplete: () => {
              // Asegurarse de que todos los frames estén ocultos
              frames.forEach((frame) => {
                if (frame) frame.style.display = "none";
              });
              window.activateSecondTimeline(); // Activar la segunda timeline aquí
            },
          });

          // Mostrar el header fijo
          const header = document.querySelector("header");
          if (header) {
            gsap.to(header, {
              opacity: 1,
              visibility: "visible",
              duration: 0.5,
            });
          }

          // La segunda timeline se activará de forma independiente
        },
        onEnterBack: () => {
          // Ocultar el header fijo al volver a subir
          const header = document.querySelector("header");
          if (header) {
            gsap.to(header, {
              opacity: 0,
              visibility: "hidden",
              duration: 0.5,
            });
          }
        },
        onLeaveBack: () => {
          // Restaurar el estado inicial de la primera animación
          gsap.set("#frames-animation", { opacity: 1 });
          showFrame(0);
        },
      },
    });

    // Ajustar la posición de inicio de la animación de la máscara
    mainTimeline
      .to(
        "#hero-key",
        {
          duration: 1.5,
          scale: 1,
          ease: "power2.out",
        },
        0.5,
      ) // Retrasar ligeramente el inicio
      .to(
        "#hero-footer",
        {
          opacity: 0,
          duration: 0.8,
          ease: "power2.in",
        },
        "<0.2",
      )
      .to(
        "#hero-play-button",
        {
          opacity: 0,
          duration: 0.8,
          ease: "power2.in",
        },
        "<0.1",
      )
      // Animación de la máscara con mejor sincronización
      .to(
        "#logo-mask",
        {
          maskSize: "clamp(80vh, 50%, 60vh)",
          webkitMaskSize: "clamp(80vh, 50%, 60vh)",
          duration: 2,
          ease: "power2.inOut",
        },
        0.7, // Iniciar después de que los frames estén ocultándose
      )
      .to(
        "#hero-key",
        {
          opacity: 0,
          duration: 1,
          ease: "power2.in",
        },
        0.8,
      )
      // Hacer que el logo vuelva a aparecer después de la animación de la máscara
      .to(
        ".logo-text",
        {
          opacity: 1,
          duration: 1.2,
          ease: "power2.inOut",
        },
        0.6,
      );
  }

  // Animaciones adicionales (mantener solo las que no son repetitivas)
  gsap.to(".keep-scrolling", {
    y: -5,
    duration: 1,
    repeat: -1,
    yoyo: true,
    ease: "power2.inOut",
  });
</script>
