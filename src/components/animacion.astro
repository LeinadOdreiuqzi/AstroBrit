<!-- Fondo principal -->
<div id="main-background"></div>

<!-- Animación de frames -->
<div id="frames-animation"></div>

<!-- Capa de gradiente (mantenida para compatibilidad) -->
<div id="gradient-layer"></div>

<!-- Contenido principal que usa ScrollTrigger como trigger -->
<div id="main-content" class="relative">
  <section class="hero-section">
    <div id="hero-key" class="hero-content"></div>
  </section>
</div>
<!-- Capa de máscara -->
<div id="logo-mask"></div>

<!-- Ícono de scroll -->
<div class="keep-scrolling">
  <svg
    width="34"
    height="14"
    viewBox="0 0 34 14"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M33.5609 1.54346C34.0381 2.5875 33.6881 3.87821 32.7791 4.42633L17.0387 13.9181L1.48663 4.42115C0.580153 3.86761 0.235986 2.57483 0.717909 1.53365C1.19983 0.492464 2.32535 0.097152 3.23182 0.650692L17.0497 9.08858L31.051 0.64551C31.96 0.0973872 33.0837 0.499411 33.5609 1.54346Z"
      fill="currentColor"></path>
  </svg>
</div>

<!-- GSAP y ScrollTrigger se cargan globalmente desde Layout.astro -->
<script is:inline>
  function waitForGSAP(timeout = 5000) {
    const start = Date.now();
    return new Promise((resolve) => {
      (function check() {
        if (window.gsap && window.ScrollTrigger) {
          try {
            window.gsap.registerPlugin(window.ScrollTrigger);
          } catch {}
          resolve();
        } else if (Date.now() - start < timeout) {
          setTimeout(check, 50);
        } else {
          resolve(); // continuar sin bloquear si tarda demasiado
        }
      })();
    });

    // Recalcular en resize para mantener recorrido coherente
    window.addEventListener("resize", () => {
      if (window.ScrollTrigger) window.ScrollTrigger.refresh();
    });
  }

  // Cargar y configurar la animación de frames
  const framesContainer = document.getElementById("frames-animation");
  const totalFrames = 89;
  let currentFrame = 0;
  const frames = [];
  let framesLoaded = 0;

  // Variables para controlar el estado de las timelines
  let firstTimelineComplete = false;
  let isHiding = false;
  let lastScrollProgress = 0;

  // Precargar y crear elementos de imagen para cada frame
  function preloadFrames() {
    return new Promise((resolve) => {
      for (let i = 1; i <= totalFrames; i++) {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = `/assets/frames/1 (${i}).webp`;
        img.alt = `Frame ${i}`;
        img.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        opacity: 0;
        pointer-events: none;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
      `;

        img.onload = () => {
          framesLoaded++;
          if (framesLoaded === totalFrames) {
            resolve();
          }
        };

        img.onerror = () => {
          console.warn(`Failed to load frame ${i}`);
          framesLoaded++;
          if (framesLoaded === totalFrames) {
            resolve();
          }
        };

        framesContainer.appendChild(img);
        frames.push(img);
      }
    });
  }

  let isAnimating = false;
  let lastRenderedFrame = -1;

  function showFrame(frameIndex) {
    // Evitar actualizaciones innecesarias
    if (frameIndex === lastRenderedFrame || !frames[frameIndex]) return;

    // Evitar solapamiento de animaciones
    if (isAnimating) return;
    isAnimating = true;

    // Usar requestAnimationFrame para sincronizar con el renderizado del navegador
    requestAnimationFrame(() => {
      try {
        // Ocultar el frame actual si existe
        if (frames[currentFrame] && currentFrame !== frameIndex) {
          frames[currentFrame].style.display = "none";
        }

        // Mostrar el nuevo frame
        const targetFrame = frames[frameIndex];
        targetFrame.style.display = "block";
        targetFrame.style.opacity = "1";

        // Actualizar el frame actual
        currentFrame = frameIndex;
        lastRenderedFrame = frameIndex;
      } catch (error) {
        console.error("Error in showFrame:", error);
      } finally {
        isAnimating = false;
      }
    });
  }

  // Función para inicializar el contenido de la segunda timeline
  function initializeSecondTimeline() {
    const secondTimelineContent = document.querySelector("main");
    if (secondTimelineContent) {
      gsap.set(secondTimelineContent, {
        opacity: 0,
        x: "100%",
        scale: 0.7,
        rotationY: 45,
        visibility: "visible",
        pointerEvents: "none",
      });
      // console.log("Segunda timeline inicializada y ocultada");
    }
  }

  // Función para ocultar la segunda timeline
  function hideSecondTimeline() {
    const secondTimelineContent = document.querySelector("main");
    const logoMask = document.querySelector("#logo-mask");

    // Ocultar instantáneamente el contenido de la segunda timeline
    if (secondTimelineContent) {
      gsap.set(secondTimelineContent, {
        opacity: 0,
        pointerEvents: "none",
      });
    }
    if (logoMask) {
      gsap.set(logoMask, { opacity: 1 });
    }

    // IMPORTANTE: No reiniciamos firstTimelineComplete a false
    // para que la animación de entrada no se repita.
  }

  // Función para activar la segunda timeline con animaciones rápidas
  window.activateSecondTimeline = () => {
    if (firstTimelineComplete) {
      // console.log("Segunda timeline ya está activa, saltando...");
      return;
    }

    firstTimelineComplete = true;
    isHiding = false;
    // console.log("Activando segunda timeline...");

    const secondTimelineContent = document.querySelector("main");
    const logoMask = document.querySelector("#logo-mask");
    const logoText = document.querySelector("main .logo-text");
    const title = document.querySelector("main .main-content h1");
    const paragraphs = document.querySelectorAll("main .main-content p");
    const skinBlock = document.querySelector("main .skin-component");

    if (!secondTimelineContent) {
      console.error("No se encontró el contenido de la segunda timeline");
      return;
    }

    // Timeline de entrada rápida y dinámica
    const entryTimeline = gsap.timeline({
      ease: "power3.out",
    });

    // 1. Ocultar logo-mask rápidamente
    entryTimeline.to(logoMask, {
      opacity: 0,
      duration: 0.8,
      ease: "power3.inOut",
    });

    // 2. Preparar el contenedor principal y sus elementos para la animación
    entryTimeline.set(secondTimelineContent, {
      pointerEvents: "auto",
      zIndex: 100,
      opacity: 1, // Asegurar que el contenedor principal sea visible
      x: "0%",
      scale: 1,
      rotationY: 0,
    });

    // Establecer estados iniciales para los elementos individuales
    if (logoText) {
      gsap.set(logoText, { opacity: 0, y: 20 });
    }
    if (title) {
      gsap.set(title, { opacity: 0, y: 30 });
    }
    if (paragraphs && paragraphs.length) {
      paragraphs.forEach((p) => gsap.set(p, { opacity: 0, y: 30 }));
    }
    if (skinBlock) {
      gsap.set(skinBlock, { opacity: 0, scale: 0.86 });
    }

    // 3. Animación de entrada de los bloques
    entryTimeline.to(
      logoText,
      {
        opacity: 1,
        y: 0,
        duration: 0.6,
        ease: "power3.out",
      },
      "<0.2",
    );

    entryTimeline.to(
      title,
      {
        opacity: 1,
        y: 0,
        duration: 0.7,
        ease: "power3.out",
      },
      "<0.1",
    );

    if (paragraphs && paragraphs.length) {
      entryTimeline.to(
        paragraphs,
        {
          opacity: 1,
          y: 0,
          duration: 0.6,
          ease: "power3.out",
          stagger: 0.06,
        },
        "<0.1",
      );
    }

    if (skinBlock) {
      entryTimeline.to(
        skinBlock,
        {
          opacity: 1,
          scale: 1,
          duration: 0.8,
          ease: "back.out(1.2)",
        },
        "<0.15",
      );
    }

    // console.log("Segunda timeline activada completamente");
  };

  // Mostrar el gradiente al cargar la página
  document.addEventListener("DOMContentLoaded", async () => {
    initializeSecondTimeline();

    await preloadFrames();

    // Mostrar el primer frame instantáneamente
    if (frames[0]) {
      frames[0].style.display = "block";
      frames[0].style.opacity = "1";
    }

    // Esperar GSAP/ScrollTrigger si aún no está listo
    await waitForGSAP();

    // Forzar que ScrollTrigger se calcule y active
    if (window.ScrollTrigger) {
      window.ScrollTrigger.refresh();
    }

    // Forzar render inmediato del primer frame y configurar animación principal
    if (window.gsap) {
      window.gsap.set("#frames-animation", {
        opacity: 1,
        immediateRender: true,
      });
      showFrame(0);
      setupMainAnimation();
      // Forzar refresco después de configurar todos los disparadores y pins
      ScrollTrigger.refresh();
    }
  });

  function setupMainAnimation() {
    // Detect mobile
    const isMobile = window.innerWidth <= 768;

    // Timeline principal con ScrollTrigger
    // Reducir recorrido en mobile para que no sea tan "pesado"
    const baseLen = isMobile
      ? window.innerHeight * 2.5
      : window.innerHeight * 4;
    const scrollLen = Math.max(baseLen, totalFrames * (isMobile ? 10 : 14));

    const mainTimeline = gsap.timeline({
      ease: "power2.inOut",
      scrollTrigger: {
        trigger: "#main-content",
        start: "top top",
        end: () => "+=" + scrollLen,
        scrub: 2.5,
        pin: true,
        anticipatePin: 1,
        invalidateOnRefresh: true,
        onUpdate: (self) => {
          const progress = self.progress;
          const frameSectionProgress = Math.min(progress / 0.7, 1);

          if (progress <= 0.7) {
            gsap.set("#frames-animation", {
              opacity: 1,
              immediateRender: false,
            });

            // Calcular el frame actual basado en el progreso
            const targetFrame = Math.min(
              Math.floor(frameSectionProgress * (totalFrames - 1)),
              totalFrames - 1,
            );
            if (targetFrame !== lastRenderedFrame) {
              showFrame(targetFrame);
            }
          } else if (progress > 0.68 && self.direction === 1 && !isHiding) {
            isHiding = true; // evitar que se repita
            gsap.to("#frames-animation", {
              opacity: 0,
              duration: 0.8,
              ease: "power2.inOut",
              onComplete: () => {
                frames.forEach((frame) => {
                  if (frame) frame.style.display = "none";
                });
                // Reinicia el estado para futuras entradas
                setTimeout(() => (isHiding = false), 1000);
              },
            });
          }
        },
        onLeave: () => {
          // Ocultar #frames-animation gradualmente
          gsap.to("#frames-animation", {
            opacity: 0,
            duration: 0.5,
            ease: "power2.in",
            onComplete: () => {
              // Asegurarse de que todos los frames estén ocultos
              frames.forEach((frame) => {
                if (frame) frame.style.display = "none";
              });
              window.activateSecondTimeline();
            },
          });

          // Mostrar el header fijo
          const header = document.querySelector("header");
          if (header) {
            gsap.to(header, {
              opacity: 1,
              visibility: "visible",
              duration: 0.5,
            });
          }

          // La segunda timeline se activará de forma independiente
        },
        onEnterBack: () => {
          // Ocultar el header fijo al volver a subir
          const header = document.querySelector("header");
          if (header) {
            gsap.to(header, {
              opacity: 0,
              visibility: "hidden",
              duration: 0.8,
            });
          }
          // Asegurarse de que la máscara vuelva a ser visible al hacer scroll hacia arriba
          gsap.set("#logo-mask", { opacity: 1 });
        },
        onLeaveBack: () => {
          // Restaurar el estado inicial de la primera animación
          gsap.set("#frames-animation", { opacity: 1 });
          showFrame(0);
        },
      },
    });

    // Ajustar la posición de inicio de la animación de la máscara
    mainTimeline
      .to(
        "#hero-key",
        {
          duration: 1.5,
          scale: 1,
          ease: "power2.out",
        },
        0.5,
      ) // Retrasar ligeramente el inicio
      // Animación de la máscara con mejor sincronización
      .to(
        "#logo-mask",
        {
          maskSize: "0vh",
          webkitMaskSize: "0vh",
          duration: 2,
          ease: "power2.inOut",
        },
        0.7,
      )
      .to(
        "#hero-key",
        {
          opacity: 0,
          duration: 1,
          ease: "power2.in",
        },
        0.8,
      )
      .to(
        ".logo-text",
        {
          opacity: 1,
          duration: 1.2,
          ease: "power2.inOut",
        },
        0.6,
      );

    // Configurar .keep-scrolling después de la pin principal
    const keepScrolling = document.querySelector(".keep-scrolling");
    if (keepScrolling) {
      // Reemplazo de la animación CSS bounce-pulse - Guardamos la referencia
      const bounceAnim = gsap.to(keepScrolling, {
        y: -5,
        scale: 1,
        opacity: 1,
        duration: 1.2,
        repeat: -1,
        yoyo: true,
        ease: "power2.inOut",
        startAt: { scale: 0.85, opacity: 0.8 },
      });

      // Esconder al llegar al footer con mayor control
      ScrollTrigger.create({
        trigger: "footer",
        start: "top bottom",
        onEnter: () => {
          bounceAnim.pause();
          gsap.to(keepScrolling, {
            opacity: 0,
            scale: 0.5,
            pointerEvents: "none",
            duration: 0.4,
          });
        },
        onLeaveBack: () => {
          gsap.to(keepScrolling, {
            opacity: 1,
            scale: 1,
            pointerEvents: "auto",
            duration: 0.4,
            onComplete: () => bounceAnim.play(),
          });
        },
        invalidateOnRefresh: true,
      });
    }
  }
</script>
